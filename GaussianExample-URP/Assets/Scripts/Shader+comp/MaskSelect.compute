// SPDX-License-Identifier: MIT
#pragma kernel ApplyMaskSelection
#pragma kernel ApplyMaskSelectionLite
#pragma kernel GatherMaskDepth
#pragma kernel ClearPerPixelDepth

struct SplatViewData
{
    float4 pos;
    float2 axis1;
    float2 axis2;
    uint2  color;
};

StructuredBuffer<SplatViewData> _SplatViewData;
StructuredBuffer<float3> _SplatPos;
StructuredBuffer<float4> _SeedWorld;
Texture2D<float>         _MaskTex;
Texture2D<float>         _DepthTex; // optional external per-pixel depth (e.g., ZoeDepth), normalized [0,1]

RWByteAddressBuffer _SelectedBits;
RWByteAddressBuffer _DepthRange;
RWByteAddressBuffer _DepthHistogram;
RWStructuredBuffer<uint> _PerPixelDepthRange;
int   _CollectHistogram;
int   _UseROI;
float4 _ROIMinMax; // x0,y0,x1,y1 in bottom-left coordinates

static const uint DEPTH_HIST_BINS = 256u;

int      _SplatCount;
int2     _MaskSize;
float    _Threshold;
int      _Mode;
int      _MorphologyMode;
int      _MorphRadiusPx;
int      _UseDepthGate;
float    _DepthCenter;
float    _DepthHalfWidth;
int      _UseBoxGate;
float4   _GateRectTLBR;
int      _UseBoxGateBL;
float4   _GateRectBL;
int      _UsePerPixelDepth;
int      _ApplyPerPixelOcclusion;
int      _SeedCount;
int      _MaskPixelCount;
float    _DepthOcclusionBias;
float2   _RenderViewportSize;
float4x4 _ObjectToWorld;
float    _SeedCullEps;
int      _UseExtDepth;        // if !=0, compare splat ndc depth against Zoe depth
float    _DepthTolerance;     // allowed NDC difference (front-only gate)
float    _DepthScale;         // Zoe->NDC scale
float    _DepthBias;          // Zoe->NDC bias
int      _UseEllipseProbe;    // if 0, only test center pixel; if 1, sample ellipse neighborhood
int      _UseCenterMask;      // if !=0, sample mask at splat center only
int      _MaxRadiusPx;        // if >0, skip splats whose screen-space radius exceeds this
int      _MinRadiusPx;        // if >0, skip splats smaller than this to avoid speckle
int      _UseZoeBand;         // if !=0, gate by ZoeDepth relative band only (no NDC mapping)
float    _ZoeCenter;          // ZoeDepth median inside mask
float    _ZoeHalfWidth;       // k * IQR inside mask
float    _MaxEccentricity;    // if >0, reject if major/minor > this
float    _MaxAreaPx;          // if >0, reject if major*minor (approx area) exceeds this
int      _AlwaysIncludeMask;  // if !=0, never drop splats that hit the SAM mask, even if depth gates fail
int      _UseFocusDepth;      // if !=0, gate by explicit focus NDC depth (from click)
float    _FocusDepth;
float    _FocusDepthTol;
float    _FocusDepthTolWide;
int      _ForceMaskOn;
int      _FocusDepthUseZoe;
float    _FocusDepthNorm;
int      _UseProbeDepthClip;
float    _ProbeDepthClip;
float    _ProbeDepthClipTol;
int      _UseProbeSphere;
float4   _ProbeSphereCenter;
float    _ProbeSphereRadius;
int      _UseZoeDepthCull;
float    _ZoeDepthCullOffset;

void SetBit(uint index)
{
    uint word = index >> 5;
    uint bit  = 1u << (index & 31);
    _SelectedBits.InterlockedOr(word * 4, bit);
}

void ClearBit(uint index)
{
    uint word = index >> 5;
    uint bit  = 1u << (index & 31);
    _SelectedBits.InterlockedAnd(word * 4, ~bit);
}

void AccumulateDepth(float depth)
{
    depth = saturate(depth);
    int depthQuant = (int)round(depth * 65535.0);
    int dummy;
    _DepthRange.InterlockedMin(0, depthQuant, dummy);
    _DepthRange.InterlockedMax(4, depthQuant, dummy);
    if (_CollectHistogram != 0)
    {
        uint bin = (uint)clamp((int)floor(depth * (DEPTH_HIST_BINS - 1.0)), 0, (int)DEPTH_HIST_BINS - 1);
        _DepthHistogram.InterlockedAdd(bin * 4u, 1, dummy);
    }
}

bool EvaluateMaskAtUv(float2 uvBL, float2 uvTL, out int2 outPix)
{
    int2 pix = int2(-1, -1);
    bool result = false;

    if (_UseROI != 0)
    {
        float x0 = _ROIMinMax.x;
        float y0 = _ROIMinMax.y;
        float x1 = _ROIMinMax.z;
        float y1 = _ROIMinMax.w;
        if (uvBL.x < x0 || uvBL.x > x1 || uvBL.y < y0 || uvBL.y > y1)
        {
            outPix = pix;
            return false;
        }
        float2 sizeBL = float2(max(x1 - x0, 1e-5), max(y1 - y0, 1e-5));
        uvBL = (uvBL - float2(x0, y0)) / sizeBL;
        uvTL = float2(uvBL.x, 1.0 - uvBL.y);
    }

    if (_UseBoxGate != 0)
    {
        if (uvTL.x < _GateRectTLBR.x || uvTL.y < _GateRectTLBR.y || uvTL.x > _GateRectTLBR.z || uvTL.y > _GateRectTLBR.w)
        {
            outPix = pix;
            return false;
        }
    }
    if (_UseBoxGateBL != 0)
    {
        if (uvBL.x < _GateRectBL.x || uvBL.y < _GateRectBL.y || uvBL.x > _GateRectBL.z || uvBL.y > _GateRectBL.w)
        {
            outPix = pix;
            return false;
        }
    }

    int2 basePix = int2(
        clamp((int)(uvTL.x * _MaskSize.x), 0, _MaskSize.x - 1),
        clamp((int)(uvTL.y * _MaskSize.y), 0, _MaskSize.y - 1)
    );
    pix = basePix;

    if (_MorphologyMode == 0 || _MorphRadiusPx <= 0)
    {
        float m = _MaskTex.Load(int3(basePix, 0)).r;
        result = (m >= _Threshold);
    }
    else if (_MorphologyMode == 1)
    {
        [loop]
        for (int dy = -_MorphRadiusPx; dy <= _MorphRadiusPx && !result; ++dy)
        {
            int yy = clamp(basePix.y + dy, 0, _MaskSize.y - 1);
            [loop]
            for (int dx = -_MorphRadiusPx; dx <= _MorphRadiusPx; ++dx)
            {
                int xx = clamp(basePix.x + dx, 0, _MaskSize.x - 1);
                float m = _MaskTex.Load(int3(xx, yy, 0)).r;
                if (m >= _Threshold)
                {
                    pix = int2(xx, yy);
                    result = true;
                    break;
                }
            }
        }
    }
    else
    {
        result = true;
        [loop]
        for (int dy = -_MorphRadiusPx; dy <= _MorphRadiusPx && result; ++dy)
        {
            int yy = clamp(basePix.y + dy, 0, _MaskSize.y - 1);
            [loop]
            for (int dx = -_MorphRadiusPx; dx <= _MorphRadiusPx; ++dx)
            {
                int xx = clamp(basePix.x + dx, 0, _MaskSize.x - 1);
                float m = _MaskTex.Load(int3(xx, yy, 0)).r;
                if (m < _Threshold)
                {
                    pix = basePix;
                    result = false;
                    break;
                }
            }
        }
    }

    outPix = pix;
    return result;
}

bool SampleMaskAtCenter(float2 ndcXY, out int2 outPix)
{
    float2 uvBL = ndcXY * 0.5 + 0.5;
    float2 uvTL = float2(uvBL.x, 1.0 - uvBL.y);
    return EvaluateMaskAtUv(uvBL, uvTL, outPix);
}

float SampleZoeAtNdc(float2 ndcXY)
{
    float2 uvBL = ndcXY * 0.5 + 0.5;
    int2 pix = int2(
        clamp((int)(uvBL.x * _MaskSize.x), 0, _MaskSize.x - 1),
        clamp((int)((1.0 - uvBL.y) * _MaskSize.y), 0, _MaskSize.y - 1)
    );
    return _DepthTex.Load(int3(pix, 0)).r;
}

bool EvaluateMaskAtNdc(float2 ndcXY, out int2 outPix)
{
    // Map NDC (-1..1, bottom=-1, top=1) to bottom-left UV (0..1)
    // Correct mapping is uvBL = ndc*0.5 + 0.5. Previous sign flip caused vertical inversion.
    float2 uvBL = ndcXY * 0.5 + 0.5;
    float2 uvTL = float2(uvBL.x, 1.0 - uvBL.y);
    return EvaluateMaskAtUv(uvBL, uvTL, outPix);
}

bool EvaluateMask(uint index, float3 ndc, out int2 outPix)
{
    int2 pix = int2(-1, -1);
    bool result = false;

    SplatViewData view = _SplatViewData[index];
    float2 axis1 = view.axis1;
    float2 axis2 = view.axis2;
    float l1 = length(axis1);
    float l2 = length(axis2);
    float axisMagnitude = l1*l1 + l2*l2;
    if (axisMagnitude <= 1e-8)
    {
        outPix = pix;
        return false;
    }
    float axisRadius = sqrt(axisMagnitude);
    float major = max(l1, l2);
    float minor = max(1e-6, min(l1, l2));
    if ((_MaxRadiusPx > 0 && axisRadius > (float)_MaxRadiusPx) ||
        (_MinRadiusPx > 0 && axisRadius < (float)_MinRadiusPx))
    {
        outPix = pix;
        return false;
    }
    if (_MaxEccentricity > 0.0 && (major / minor) > _MaxEccentricity)
    {
        outPix = pix;
        return false;
    }
    if (_MaxAreaPx > 0.0 && (major * minor) > _MaxAreaPx)
    {
        outPix = pix;
        return false;
    }

    if (_UseEllipseProbe == 0)
    {
        result = EvaluateMaskAtNdc(ndc.xy, pix);
        outPix = pix;
        return result;
    }

    if (_RenderViewportSize.x <= 0.0 || _RenderViewportSize.y <= 0.0)
    {
        outPix = pix;
        return false;
    }
    float2 viewport = max(_RenderViewportSize, float2(1.0, 1.0));
    float2 invViewport = 2.0 / viewport;
    const float ringScales[4] = { 0.55f, 0.95f, 1.30f, 1.70f };
    const float2 sampleDirs[8] = {
        float2( 1.0f,  0.0f),
        float2(-1.0f,  0.0f),
        float2( 0.0f,  1.0f),
        float2( 0.0f, -1.0f),
        float2( 0.7071f,  0.7071f),
        float2(-0.7071f,  0.7071f),
        float2( 0.7071f, -0.7071f),
        float2(-0.7071f, -0.7071f)
    };
    float adapt = saturate(axisRadius * 0.6f);

    [loop]
    for (int ri = 0; ri < 4 && !result; ++ri)
    {
        float ringScale = ringScales[ri] * (0.6f + 0.4f * adapt);
        [loop]
        for (int di = 0; di < 8; ++di)
        {
            float2 dir = sampleDirs[di];
            float2 offset = (axis1 * dir.x + axis2 * dir.y) * ringScale;
            float2 sampleNdc = ndc.xy + offset * invViewport;
            if (sampleNdc.x < -1.3 || sampleNdc.x > 1.3 || sampleNdc.y < -1.3 || sampleNdc.y > 1.3)
                continue;
            if (EvaluateMaskAtNdc(sampleNdc, pix))
            {
                result = true;
                break;
            }
        }
    }

    outPix = pix;
    return result;
}

[numthreads(128,1,1)]
void ApplyMaskSelection(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= (uint)_SplatCount) return;

    float4 clipPos = _SplatViewData[i].pos;
    if (clipPos.w <= 0.0) return;

    float3 ndc = clipPos.xyz / clipPos.w;
    if (ndc.x < -1.0 || ndc.x > 1.0 ||
        ndc.y < -1.0 || ndc.y > 1.0)
        return;
    float depthNdc = saturate(ndc.z);

    if (_UseDepthGate != 0)
    {
        if (depthNdc < (_DepthCenter - _DepthHalfWidth) || depthNdc > (_DepthCenter + _DepthHalfWidth))
            return;
    }

    bool forceMask = (_ForceMaskOn != 0);
    int2 maskPix;
    bool inMaskRaw;
    bool inMask;
    if (forceMask)
    {
        maskPix = int2(-1, -1);
        inMaskRaw = true;
        inMask = true;
    }
    else if (_UseCenterMask != 0)
    {
        inMaskRaw = SampleMaskAtCenter(ndc.xy, maskPix);
        inMask = inMaskRaw;
    }
    else
    {
        inMaskRaw = EvaluateMask(i, ndc, maskPix);
        inMask = inMaskRaw;
    }

    // Relative ZoeDepth band gate (object-only, no NDC mapping)
    if (!forceMask && inMask && _UseZoeBand != 0 && maskPix.x >= 0)
    {
        float extD = _DepthTex.Load(int3(maskPix, 0)).r;
        if (abs(extD - _ZoeCenter) > _ZoeHalfWidth)
            inMask = false;
    }

    if (inMask && _UseZoeDepthCull != 0)
    {
        float zoeDepth = (maskPix.x >= 0) ? _DepthTex.Load(int3(maskPix, 0)).r : saturate(SampleZoeAtNdc(ndc.xy));
        if (depthNdc - zoeDepth > _ZoeDepthCullOffset)
            inMask = false;
    }

    if (inMask && _UseFocusDepth != 0)
    {
        if (_FocusDepthUseZoe != 0)
        {
            float zoe = saturate(SampleZoeAtNdc(ndc.xy));
            if (abs(zoe - _FocusDepthNorm) > _FocusDepthTolWide)
                inMask = false;
        }
        else
        {
            if (depthNdc - _FocusDepth > _FocusDepthTolWide)
                inMask = false;
        }
    }

    if (inMask && _UseExtDepth != 0)
    {
        float extD = saturate(SampleZoeAtNdc(ndc.xy));
        float mapped = extD * _DepthScale + _DepthBias;
        if (depthNdc - mapped > _DepthTolerance)
            inMask = false;
    }

    if (inMask && _UseProbeDepthClip != 0)
    {
        if (depthNdc - _ProbeDepthClip > _ProbeDepthClipTol)
            inMask = false;
    }

    if (inMask && _UseProbeSphere != 0)
    {
        float3 localPosSphere = _SplatPos[i];
        float3 worldPosSphere = mul(_ObjectToWorld, float4(localPosSphere, 1.0)).xyz;
        float3 diff = worldPosSphere - _ProbeSphereCenter.xyz;
        if (dot(diff, diff) > (_ProbeSphereRadius * _ProbeSphereRadius))
            inMask = false;
    }

    if (inMask && _UseProbeDepthClip != 0)
    {
        if (depthNdc - _ProbeDepthClip > _ProbeDepthClipTol)
            inMask = false;
    }

    bool sphereWorldComputed = false;
    float3 sphereWorldPos = 0;
    if (inMask && _UseProbeSphere != 0)
    {
        float3 localPosSphere = _SplatPos[i];
        sphereWorldPos = mul(_ObjectToWorld, float4(localPosSphere, 1.0)).xyz;
        sphereWorldComputed = true;
        float3 diff = sphereWorldPos - _ProbeSphereCenter.xyz;
        if (dot(diff, diff) > (_ProbeSphereRadius * _ProbeSphereRadius))
            inMask = false;
    }

    // Absolute inclusion: if requested, keep any splat that hits the SAM mask
    if (!forceMask && !inMask && _AlwaysIncludeMask != 0 && inMaskRaw && maskPix.x >= 0)
    {
        inMask = true;
    }

    if (inMask && _ApplyPerPixelOcclusion != 0 && maskPix.x >= 0)
    {
        uint pixelIndex = (uint)(maskPix.y * _MaskSize.x + maskPix.x);
        uint baseIndex = pixelIndex << 1;
        uint minStored = _PerPixelDepthRange[baseIndex];
        if (minStored != 0xFFFFFFFFu)
        {
            float minDepth = minStored / 65535.0;
            float tolerance = max(_DepthOcclusionBias, 1e-4f);
            if (depthNdc - minDepth > tolerance)
                inMask = false;
        }
    }

    if (inMask && _SeedCount > 0)
    {
        float3 localPos = _SplatPos[i];
        float3 worldPos;
        if (sphereWorldComputed)
            worldPos = sphereWorldPos;
        else
            worldPos = mul(_ObjectToWorld, float4(localPos, 1.0)).xyz;
        bool insideSeed = false;
        [loop]
        for (int s = 0; s < _SeedCount; ++s)
        {
            float4 seed = _SeedWorld[s];
            float3 diff = worldPos - seed.xyz;
            if (dot(diff, diff) <= seed.w + _SeedCullEps)
            {
                insideSeed = true;
                break;
            }
        }
        if (!insideSeed)
            inMask = false;
    }

    if (inMask)
    {
        if (_Mode == 2)
            ClearBit(i);
        else
            SetBit(i);
        AccumulateDepth(depthNdc);
    }
    else if (_Mode == 0)
    {
        ClearBit(i);
    }
}

// A stripped-down kernel that applies the mask without any optional features.
// No depth accumulation, no per-pixel occlusion, no seed culling; avoids touching
// optional buffers so Unity does not require them to be bound.
[numthreads(128,1,1)]
void ApplyMaskSelectionLite(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= (uint)_SplatCount) return;

    float4 clipPos = _SplatViewData[i].pos;
    if (clipPos.w <= 0.0) return;

    float3 ndc = clipPos.xyz / clipPos.w;
    if (ndc.x < -1.0 || ndc.x > 1.0 ||
        ndc.y < -1.0 || ndc.y > 1.0)
        return;
    float depthNdc = saturate(ndc.z);

    // Depth gate off in lite kernel (or leave uniform-controlled)
    if (_UseDepthGate != 0)
    {
        if (depthNdc < (_DepthCenter - _DepthHalfWidth) || depthNdc > (_DepthCenter + _DepthHalfWidth))
            return;
    }

    bool forceMask = (_ForceMaskOn != 0);
    int2 maskPix;
    bool inMaskRaw;
    bool inMask;
    if (forceMask)
    {
        maskPix = int2(-1, -1);
        inMaskRaw = true;
        inMask = true;
    }
    else if (_UseCenterMask != 0)
    {
        inMaskRaw = SampleMaskAtCenter(ndc.xy, maskPix);
        inMask = inMaskRaw;
    }
    else
    {
        inMaskRaw = EvaluateMask(i, ndc, maskPix);
        inMask = inMaskRaw;
    }
    if (!forceMask && inMask && _UseZoeBand != 0 && maskPix.x >= 0)
    {
        float extD = _DepthTex.Load(int3(maskPix, 0)).r;
        if (abs(extD - _ZoeCenter) > _ZoeHalfWidth)
            inMask = false;
    }

    if (inMask && _UseFocusDepth != 0)
    {
        if (_FocusDepthUseZoe != 0)
        {
            float zoe = saturate(SampleZoeAtNdc(ndc.xy));
            if (abs(zoe - _FocusDepthNorm) > _FocusDepthTolWide)
                inMask = false;
        }
        else
        {
            if (depthNdc - _FocusDepth > _FocusDepthTolWide)
                inMask = false;
        }
    }

    if (inMask && _UseExtDepth != 0)
    {
        float extD = saturate(SampleZoeAtNdc(ndc.xy));
        float mapped = extD * _DepthScale + _DepthBias;
        if (depthNdc - mapped > _DepthTolerance)
            inMask = false;
    }

    if (inMask && _UseProbeDepthClip != 0)
    {
        if (depthNdc - _ProbeDepthClip > _ProbeDepthClipTol)
            inMask = false;
    }

    // Absolute inclusion: if requested, keep any splat that hits the SAM mask
    if (!forceMask && !inMask && _AlwaysIncludeMask != 0 && inMaskRaw && maskPix.x >= 0)
    {
        inMask = true;
    }

    if (inMask)
    {
        if (_Mode == 2)
            ClearBit(i);
        else
            SetBit(i);
    }
    else if (_Mode == 0)
    {
        ClearBit(i);
    }
}

[numthreads(128,1,1)]
void GatherMaskDepth(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= (uint)_SplatCount) return;

    float4 clipPos = _SplatViewData[i].pos;
    if (clipPos.w <= 0.0) return;

    float3 ndc = clipPos.xyz / clipPos.w;
    if (ndc.x < -1.0 || ndc.x > 1.0 ||
        ndc.y < -1.0 || ndc.y > 1.0)
        return;
    float depthNdc = saturate(ndc.z);

    int2 maskPix;
    if (EvaluateMask(i, ndc, maskPix))
    {
        if (_UsePerPixelDepth != 0 && maskPix.x >= 0)
        {
            uint pixelIndex = (uint)(maskPix.y * _MaskSize.x + maskPix.x);
            uint depthQuant = (uint)round(ndc.z * 65535.0);
            uint baseIndex = pixelIndex << 1;
            uint dummy;
            InterlockedMin(_PerPixelDepthRange[baseIndex], depthQuant, dummy);
            InterlockedMax(_PerPixelDepthRange[baseIndex + 1u], depthQuant, dummy);
        }
        AccumulateDepth(depthNdc);
    }
}

[numthreads(256,1,1)]
void ClearPerPixelDepth(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= (uint)_MaskPixelCount) return;
    uint baseIndex = idx << 1;
    _PerPixelDepthRange[baseIndex] = 0xFFFFFFFFu;
    _PerPixelDepthRange[baseIndex + 1u] = 0u;
}
