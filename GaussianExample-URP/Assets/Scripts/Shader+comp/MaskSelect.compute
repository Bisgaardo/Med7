// SPDX-License-Identifier: MIT
#pragma kernel ApplyMaskSelection
#pragma kernel ApplyMaskSelectionLite
#pragma kernel GatherMaskDepth
#pragma kernel ClearPerPixelDepth

struct SplatViewData
{
    float4 pos;
    float2 axis1;
    float2 axis2;
    uint2  color;
};

StructuredBuffer<SplatViewData> _SplatViewData;
StructuredBuffer<float3> _SplatPos;
StructuredBuffer<float4> _SeedWorld;
Texture2D<float>         _MaskTex;

RWByteAddressBuffer _SelectedBits;
RWByteAddressBuffer _DepthRange;
RWByteAddressBuffer _DepthHistogram;
RWStructuredBuffer<uint> _PerPixelDepthRange;
int   _CollectHistogram;
int   _UseROI;
float4 _ROIMinMax; // x0,y0,x1,y1 in bottom-left coordinates

static const uint DEPTH_HIST_BINS = 256u;

int      _SplatCount;
int2     _MaskSize;
float    _Threshold;
int      _Mode;
int      _MorphologyMode;
int      _MorphRadiusPx;
int      _UseDepthGate;
float    _DepthCenter;
float    _DepthHalfWidth;
int      _UseBoxGate;
float4   _GateRectTLBR;
int      _UseBoxGateBL;
float4   _GateRectBL;
int      _UsePerPixelDepth;
int      _ApplyPerPixelOcclusion;
int      _SeedCount;
int      _MaskPixelCount;
float    _DepthOcclusionBias;
float2   _RenderViewportSize;
float4x4 _ObjectToWorld;
float    _SeedCullEps;

void SetBit(uint index)
{
    uint word = index >> 5;
    uint bit  = 1u << (index & 31);
    _SelectedBits.InterlockedOr(word * 4, bit);
}

void ClearBit(uint index)
{
    uint word = index >> 5;
    uint bit  = 1u << (index & 31);
    _SelectedBits.InterlockedAnd(word * 4, ~bit);
}

void AccumulateDepth(float depth)
{
    depth = saturate(depth);
    int depthQuant = (int)round(depth * 65535.0);
    int dummy;
    _DepthRange.InterlockedMin(0, depthQuant, dummy);
    _DepthRange.InterlockedMax(4, depthQuant, dummy);
    if (_CollectHistogram != 0)
    {
        uint bin = (uint)clamp((int)floor(depth * (DEPTH_HIST_BINS - 1.0)), 0, (int)DEPTH_HIST_BINS - 1);
        _DepthHistogram.InterlockedAdd(bin * 4u, 1, dummy);
    }
}

bool EvaluateMaskAtUv(float2 uvBL, float2 uvTL, out int2 outPix)
{
    outPix = int2(-1, -1);

    if (_UseROI != 0)
    {
        float x0 = _ROIMinMax.x;
        float y0 = _ROIMinMax.y;
        float x1 = _ROIMinMax.z;
        float y1 = _ROIMinMax.w;
        if (uvBL.x < x0 || uvBL.x > x1 || uvBL.y < y0 || uvBL.y > y1)
            return false;
        float2 sizeBL = float2(max(x1 - x0, 1e-5), max(y1 - y0, 1e-5));
        uvBL = (uvBL - float2(x0, y0)) / sizeBL;
        uvTL = float2(uvBL.x, 1.0 - uvBL.y);
    }

    if (_UseBoxGate != 0)
    {
        if (uvTL.x < _GateRectTLBR.x || uvTL.y < _GateRectTLBR.y || uvTL.x > _GateRectTLBR.z || uvTL.y > _GateRectTLBR.w)
            return false;
    }
    if (_UseBoxGateBL != 0)
    {
        if (uvBL.x < _GateRectBL.x || uvBL.y < _GateRectBL.y || uvBL.x > _GateRectBL.z || uvBL.y > _GateRectBL.w)
            return false;
    }

    int2 basePix = int2(
        clamp((int)(uvTL.x * _MaskSize.x), 0, _MaskSize.x - 1),
        clamp((int)(uvTL.y * _MaskSize.y), 0, _MaskSize.y - 1)
    );
    outPix = basePix;

    if (_MorphologyMode == 0 || _MorphRadiusPx <= 0)
    {
        float m = _MaskTex.Load(int3(basePix, 0)).r;
        return (m >= _Threshold);
    }
    else if (_MorphologyMode == 1)
    {
        [loop]
        for (int dy = -_MorphRadiusPx; dy <= _MorphRadiusPx; ++dy)
        {
            int yy = clamp(basePix.y + dy, 0, _MaskSize.y - 1);
            [loop]
            for (int dx = -_MorphRadiusPx; dx <= _MorphRadiusPx; ++dx)
            {
                int xx = clamp(basePix.x + dx, 0, _MaskSize.x - 1);
                float m = _MaskTex.Load(int3(xx, yy, 0)).r;
                if (m >= _Threshold)
                {
                    outPix = int2(xx, yy);
                    return true;
                }
            }
        }
        outPix = basePix;
        return false;
    }
    else
    {
        [loop]
        for (int dy = -_MorphRadiusPx; dy <= _MorphRadiusPx; ++dy)
        {
            int yy = clamp(basePix.y + dy, 0, _MaskSize.y - 1);
            [loop]
            for (int dx = -_MorphRadiusPx; dx <= _MorphRadiusPx; ++dx)
            {
                int xx = clamp(basePix.x + dx, 0, _MaskSize.x - 1);
                float m = _MaskTex.Load(int3(xx, yy, 0)).r;
                if (m < _Threshold)
                {
                    outPix = basePix;
                    return false;
                }
            }
        }
        outPix = basePix;
        return true;
    }
}

bool EvaluateMaskAtNdc(float2 ndcXY, out int2 outPix)
{
    float2 uvBL = ndcXY * float2(0.5, -0.5) + float2(0.5, 0.5);
    float2 uvTL = float2(uvBL.x, 1.0 - uvBL.y);
    return EvaluateMaskAtUv(uvBL, uvTL, outPix);
}

bool EvaluateMask(uint index, float3 ndc, out int2 outPix)
{
    if (EvaluateMaskAtNdc(ndc.xy, outPix))
        return true;

    if (_RenderViewportSize.x <= 0.0 || _RenderViewportSize.y <= 0.0)
    {
        outPix = int2(-1, -1);
        return false;
    }

    SplatViewData view = _SplatViewData[index];
    float2 axis1 = view.axis1;
    float2 axis2 = view.axis2;
    float axisMagnitude = dot(axis1, axis1) + dot(axis2, axis2);
    if (axisMagnitude <= 1e-8)
    {
        outPix = int2(-1, -1);
        return false;
    }

    float2 viewport = max(_RenderViewportSize, float2(1.0, 1.0));
    float2 invViewport = 2.0 / viewport;
    const float ringScales[4] = { 0.55f, 0.95f, 1.30f, 1.70f };
    const float2 sampleDirs[8] = {
        float2( 1.0f,  0.0f),
        float2(-1.0f,  0.0f),
        float2( 0.0f,  1.0f),
        float2( 0.0f, -1.0f),
        float2( 0.7071f,  0.7071f),
        float2(-0.7071f,  0.7071f),
        float2( 0.7071f, -0.7071f),
        float2(-0.7071f, -0.7071f)
    };

    float axisRadius = sqrt(axisMagnitude);
    float adapt = saturate(axisRadius * 0.6f);

    [loop]
    for (int ri = 0; ri < 4; ++ri)
    {
        float ringScale = ringScales[ri] * (0.6f + 0.4f * adapt);
        [loop]
        for (int di = 0; di < 8; ++di)
        {
            float2 dir = sampleDirs[di];
            float2 offset = (axis1 * dir.x + axis2 * dir.y) * ringScale;
            float2 sampleNdc = ndc.xy + offset * invViewport;
            if (sampleNdc.x < -1.3 || sampleNdc.x > 1.3 || sampleNdc.y < -1.3 || sampleNdc.y > 1.3)
                continue;
            if (EvaluateMaskAtNdc(sampleNdc, outPix))
                return true;
        }
    }

    outPix = int2(-1, -1);
    return false;
}

[numthreads(128,1,1)]
void ApplyMaskSelection(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= (uint)_SplatCount) return;

    float4 clipPos = _SplatViewData[i].pos;
    if (clipPos.w <= 0.0) return;

    float3 ndc = clipPos.xyz / clipPos.w;
    if (ndc.x < -1.0 || ndc.x > 1.0 ||
        ndc.y < -1.0 || ndc.y > 1.0)
        return;
    float depthNdc = saturate(ndc.z);

    if (_UseDepthGate != 0)
    {
        if (depthNdc < (_DepthCenter - _DepthHalfWidth) || depthNdc > (_DepthCenter + _DepthHalfWidth))
            return;
    }

    int2 maskPix;
    bool inMask = EvaluateMask(i, ndc, maskPix);

    if (inMask && _ApplyPerPixelOcclusion != 0 && maskPix.x >= 0)
    {
        uint pixelIndex = (uint)(maskPix.y * _MaskSize.x + maskPix.x);
        uint baseIndex = pixelIndex << 1;
        uint minStored = _PerPixelDepthRange[baseIndex];
        if (minStored != 0xFFFFFFFFu)
        {
            uint maxStored = _PerPixelDepthRange[baseIndex + 1u];
            float minDepth = minStored / 65535.0;
            float maxDepth = (maxStored > minStored ? maxStored : minStored) / 65535.0;
            float depthSpan = maxDepth - minDepth;
            float tolerance = max(depthSpan, _DepthOcclusionBias * 0.5f);
            tolerance += _DepthOcclusionBias * 2.0f;
            if (depthNdc - minDepth > tolerance)
                inMask = false;
        }
    }

    if (inMask && _SeedCount > 0)
    {
        float3 localPos = _SplatPos[i];
        float3 worldPos = mul(_ObjectToWorld, float4(localPos, 1.0)).xyz;
        bool insideSeed = false;
        [loop]
        for (int s = 0; s < _SeedCount; ++s)
        {
            float4 seed = _SeedWorld[s];
            float3 diff = worldPos - seed.xyz;
            if (dot(diff, diff) <= seed.w + _SeedCullEps)
            {
                insideSeed = true;
                break;
            }
        }
        if (!insideSeed)
            inMask = false;
    }

    if (inMask)
    {
        if (_Mode == 2)
            ClearBit(i);
        else
            SetBit(i);
        AccumulateDepth(depthNdc);
    }
    else if (_Mode == 0)
    {
        ClearBit(i);
    }
}

// A stripped-down kernel that applies the mask without any optional features.
// No depth accumulation, no per-pixel occlusion, no seed culling; avoids touching
// optional buffers so Unity does not require them to be bound.
[numthreads(128,1,1)]
void ApplyMaskSelectionLite(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= (uint)_SplatCount) return;

    float4 clipPos = _SplatViewData[i].pos;
    if (clipPos.w <= 0.0) return;

    float3 ndc = clipPos.xyz / clipPos.w;
    if (ndc.x < -1.0 || ndc.x > 1.0 ||
        ndc.y < -1.0 || ndc.y > 1.0)
        return;
    float depthNdc = saturate(ndc.z);

    // Depth gate off in lite kernel (or leave uniform-controlled)
    if (_UseDepthGate != 0)
    {
        if (depthNdc < (_DepthCenter - _DepthHalfWidth) || depthNdc > (_DepthCenter + _DepthHalfWidth))
            return;
    }

    int2 maskPix;
    bool inMask = EvaluateMask(i, ndc, maskPix);

    if (inMask)
    {
        if (_Mode == 2)
            ClearBit(i);
        else
            SetBit(i);
    }
    else if (_Mode == 0)
    {
        ClearBit(i);
    }
}

[numthreads(128,1,1)]
void GatherMaskDepth(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= (uint)_SplatCount) return;

    float4 clipPos = _SplatViewData[i].pos;
    if (clipPos.w <= 0.0) return;

    float3 ndc = clipPos.xyz / clipPos.w;
    if (ndc.x < -1.0 || ndc.x > 1.0 ||
        ndc.y < -1.0 || ndc.y > 1.0)
        return;
    float depthNdc = saturate(ndc.z);

    int2 maskPix;
    if (EvaluateMask(i, ndc, maskPix))
    {
        if (_UsePerPixelDepth != 0 && maskPix.x >= 0)
        {
            uint pixelIndex = (uint)(maskPix.y * _MaskSize.x + maskPix.x);
            uint depthQuant = (uint)round(ndc.z * 65535.0);
            uint baseIndex = pixelIndex << 1;
            uint dummy;
            InterlockedMin(_PerPixelDepthRange[baseIndex], depthQuant, dummy);
            InterlockedMax(_PerPixelDepthRange[baseIndex + 1u], depthQuant, dummy);
        }
        AccumulateDepth(depthNdc);
    }
}

[numthreads(256,1,1)]
void ClearPerPixelDepth(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= (uint)_MaskPixelCount) return;
    uint baseIndex = idx << 1;
    _PerPixelDepthRange[baseIndex] = 0xFFFFFFFFu;
    _PerPixelDepthRange[baseIndex + 1u] = 0u;
}
